import { Request, Response } from 'express';
import { v4 as uuid } from 'uuid';

import { ConfigManager } from '../../../../../ConfigManager';
import winston from 'winston';
import { ModuleClient, Message } from 'azure-iot-device';
import { Mqtt as IotHubTransport } from 'azure-iot-device-mqtt';
import { inspect } from 'util';

let configManager: ConfigManager;
let moduleClient: ModuleClient;

/**
 * Event payload for an dmg azure function call
 */
interface CommandEventPayload {
  command?: string;
  layer?: string;
  release?: string;
  twinVersion?: string;
  baseLayerVersion?: string;
  locale?: string;
}

/**
 * Version information for a available mdclight version send to frontend
 */
type VersionInformation = {
  release: string;
  BaseLayerVersion: string;
  releaseNotes: string;
  OSVersion: string;
  releaseNotesMissingReason: string;
};

/**
 * Payload received from from azure functions
 */
type AzureResponsePayload = ProgressPayload | UpdatesResultPayload;

/**
 * Payload response with progress status
 */
type ProgressPayload = {
  progress: any;
};

/**
 * Payload response with final result
 */
type UpdatesResultPayload = {
  result: UpdateResult;
};

/**
 * Result after update trigger
 */
type UpdateTriggeredResultPayload = {
  result: Result;
};

/**
 * Result Mesasge
 */
type Result = {
  message: string;
};

/**
 * Result message with list of available updates
 */
type UpdateResult = Result & {
  updateList: Array<AzureUpdateEntry>;
};

/**
 * Payload if any error accurse inside azure function
 */
type ErrorResult = {
  error: {
    code?: number;
    message: string;
    data?: any;
  };
};

/**
 * Type guard
 */
function isUpdatesResultPayload(obj: any): obj is UpdatesResultPayload {
  return (
    obj &&
    obj.result &&
    obj.result.updateList &&
    Array.isArray(obj.result.updateList) &&
    typeof obj.result.message === 'string'
  );
}
/**
 * Type Guard
 */
function isUpdateTriggeredResultPayload(
  obj: any
): obj is UpdateTriggeredResultPayload {
  return (
    obj &&
    obj.result &&
    obj.result.message &&
    typeof obj.result.message === 'string' &&
    typeof obj.result.updateList === 'undefined'
  );
}
/**
 *
 * @param obj object to test
 * @returns is object from type ErrorResult
 */
function isErrorResultPayload(obj: any): obj is ErrorResult {
  return (
    obj &&
    obj.error &&
    typeof obj.error === 'object' &&
    obj.error.message &&
    typeof obj.error.message === 'string'
  );
}

/**
 * Response message from azure function
 */
type AzureResponse = {
  requestId: string; // UUID generated by Azure backend
  methodName: string; // Name we register
  payload: {
    command: 'get-mdclight-updates' | 'update-mdclight-version';
    commandId: string; // Same as methodName
    payload:
      | ProgressPayload
      | UpdatesResultPayload
      | UpdateTriggeredResultPayload
      | ErrorResult;
  };
};

/**
 * Entry inside update deploymentData manifest
 */
type ContainerVersionsEntry = { name: string; tag: string };

/**
 * Update release entry
 */
type AzureUpdateEntry = {
  release: string;
  date: string;
  appliedTo: [{ regions: Array<any>; customer_clusters: Array<any> }];
  deploymentData: {
    BaseLayerVersion: string;
    OSVersion: string;
    containerVersions: Array<ContainerVersionsEntry>;
  };
  releaseNotes: string;
  releaseNotesMissingReason: string;
};

/**
 * Set ConfigManager to make accessible for local function
 * @param {ConfigManager} config
 */
export function setConfigManager(config: ConfigManager) {
  configManager = config;
}

/**
 * Get System Info
 * @param  {Request} request
 * @param  {Response} response
 */
async function systemInfoGetHandler(request: Request, response: Response) {
  const systemInfo = await configManager.getSystemInformation();
  response.status(200).json(systemInfo);
}

/**
 * Helper function to handle dev environment. Log information and set response status and msg
 *
 * @param response  express response object
 * @param logPrefix for logging
 * @returns         boolean value
 */
function isDevEnvironment(response: Response, logPrefix: string): boolean {
  if (process.env.NODE_ENV === 'development') {
    const warn = `${logPrefix} development environment detected. Update mechanisms not available.`;
    winston.warn(warn);
    response.status(500).json({
      msg: warn.replace(logPrefix + ' d', 'D')
    });
    return true;
  }
  return false;
}

/**
 * Return available MDCL versions higher than the currently installed.
 * Update information are requested from azure backend.
 */
async function getMDCLUpdates(request: Request, response: Response) {
  const logPrefix = `SystemInfo::getMDCLUpdates`;
  winston.info(`${logPrefix} routes handler called.`);

  if (isDevEnvironment(response, logPrefix)) return;

  /**
   * Receive responses with all available mdclight updates
   *
   * @param error                 Any error during collecting available updates
   * @param azureResponse         Response from azure function
   * @param azureFunctionCallback Response object to send receive ack to azure function
   */
  const updateCbHandler = async (
    error: any,
    azureResponse: AzureResponse,
    azureFunctionCallback
  ) => {
    winston.verbose(
      `${logPrefix} updateCbHandler called with ID: ${azureResponse.payload.commandId}`
    );
    const errorPayload =
      isErrorResultPayload(azureResponse.payload.payload) &&
      azureResponse.payload.payload;
    if (error || errorPayload) {
      winston.error(
        `${logPrefix} receive error from azure function call due to ${JSON.stringify(
          error ?? errorPayload.error.message
        )}`
      );
      return response.status(503).json({
        error: 'Unable to get update information.'
      });
    }

    // ACK response
    winston.debug(
      `${logPrefix} acknowledge receive of message from called azure function.`
    );
    azureFunctionCallback.send(200, {
      message: `ACK`
    });

    if (isUpdatesResultPayload(azureResponse.payload.payload)) {
      winston.debug(
        `Receive result payload from azure with payload: ${JSON.stringify(
          azureResponse.payload
        )}`
      );
      await shutdownModuleClient();
      const status =
        azureResponse.payload.payload.result.updateList.length > 0 ? 200 : 204; // OK or no content

      const message =
        status === 200
          ? 'List of available MDCL updates.'
          : 'No updates available.';

      const updates: Array<VersionInformation> =
        azureResponse.payload.payload.result.updateList.map(
          ({
            release,
            releaseNotes,
            releaseNotesMissingReason,
            deploymentData: { BaseLayerVersion, OSVersion }
          }) => {
            return {
              release,
              releaseNotes,
              releaseNotesMissingReason,
              BaseLayerVersion,
              OSVersion
            };
          }
        );

      return response.status(status).json({
        message,
        updates
      });
    }
    winston.info(
      `${logPrefix} callback called without final result ${JSON.stringify(
        azureResponse
      )}. Waiting for final result.`
    );
    return;
  };

  await setUpModuleClient().catch((error) => {
    winston.error(
      `${logPrefix} error setting up module client due to ${JSON.stringify(
        error || ''
      )}`
    );
    return response.status(500).json({
      msg: `No CelosXChange connection available.`
    });
  });

  await sendGetUpdateInfos(updateCbHandler);
}

/**
 * Trigger update mechanism of mdclight docker images.
 */
async function updateMdcl(request: Request, response: Response) {
  const logPrefix = `SystemInfo::updateMdcl`;
  winston.info(`${logPrefix} routes handler called.`);

  if (isDevEnvironment(response, logPrefix)) return;

  const payloadSend: {
    release: VersionInformation['release'];
    baseLayerVersion: VersionInformation['BaseLayerVersion'];
  } = request.body;

  if (typeof payloadSend.release === 'undefined') {
    winston.warn(`${logPrefix} called without version information`);
    response
      .status(400)
      .json({ error: 'No version information in request found.' });
    return;
  }
  if (typeof payloadSend.baseLayerVersion === 'undefined') {
    winston.warn(`${logPrefix} called without baseLayerVersion information`);
    response
      .status(400)
      .json({ error: 'No version information in request found.' });
    return;
  }

  /**
   * Receive responses after update was triggered.
   *
   * @param error                 Any error during collecting available updates
   * @param azureResponse         Response from azure function
   * @param azureFunctionCallback Response object to send receive ack to azure function
   */
  const triggeredUpdateCbHandler = async (
    error: any,
    azureResponse: AzureResponse,
    azureFunctionCallback
  ) => {
    winston.verbose(
      `${logPrefix} triggeredUpdateCbHandler called with ID: ${azureResponse.payload.commandId}`
    );
    const errorPayload =
      isErrorResultPayload(azureResponse.payload.payload) &&
      azureResponse.payload.payload;
    if (error || errorPayload) {
      winston.error(
        `${logPrefix} receive error from azure function call due to ${JSON.stringify(
          error ?? errorPayload.error.message
        )}`
      );
      return response.status(503).json({
        error: 'No update possible. Please try again later'
      });
    }
    const {
      payload: { commandId, payload }
    } = azureResponse;

    // ACK response
    winston.debug(
      `${logPrefix} acknowledge receive of message from called azure function.`
    );
    // ACK response
    azureFunctionCallback.send(200, {
      message: `ACK`
    });

    if (isUpdateTriggeredResultPayload(payload)) {
      await shutdownModuleClient();
      const status = /success/i.test(payload.result.message) ? 202 : 404;

      const error = status === 202 ? undefined : 'Version not found.';
      const message = status === 202 ? 'Update started.' : undefined;
      const version = status === 202 ? payloadSend.release : undefined;

      const sendObj = {
        error,
        message,
        version
      };
      return response.status(status).json(JSON.parse(JSON.stringify(sendObj)));
    }
    winston.info(
      `${logPrefix} receive response without final result ${JSON.stringify(
        azureResponse
      )}. Wait for final result.`
    );
    return;
  };

  await setUpModuleClient().catch((error) => {
    winston.error(
      `${logPrefix} error setting up module client due to ${JSON.stringify(
        error || ''
      )}`
    );
    return response.status(500).json({
      msg: `No CelosXChange connection available.`
    });
  });

  await sendMdclUpdateCommand(triggeredUpdateCbHandler, payloadSend);
}

/**
 * Setup instance of module client.
 *  reject in case of:  - Missing environment information.
 *                      - Connection to IoT Datahub not possible.
 */
async function setUpModuleClient(): Promise<void> {
  const logPrefix = `systeminfo::setUpModuleClient`;

  if (moduleClient) {
    return Promise.resolve();
  }

  winston.info(
    `${logPrefix} module client not yet instantiated. Creating module client.`
  );
  moduleClient = await ModuleClient.fromEnvironment(IotHubTransport).catch(
    (error) => {
      moduleClient = null;
      return Promise.reject(
        `${logPrefix} error creating module client due to ${JSON.stringify(
          error || ''
        )}.`
      );
    }
  );
  winston.verbose(`${logPrefix} module client successfully created.`);
  await moduleClient.open().catch((error) => {
    return Promise.reject(
      `${logPrefix} error connecting module client due to ${JSON.stringify(
        error || ''
      )}.`
    );
  });
  winston.verbose(`${logPrefix} moduleClient instance connected.`);
}

/**
 * Shutdown module client
 */
async function shutdownModuleClient(): Promise<void> {
  const logPrefix = `systeminfo::shutdownModuleClient`;

  winston.info(`${logPrefix} start module client shutdown.`);
  if (!moduleClient) {
    winston.warn(`${logPrefix} no module client to shutdown available.`);
    return Promise.resolve();
  }

  try {
    moduleClient.removeAllListeners();
    await moduleClient.close();
    moduleClient = null;
    winston.info(`${logPrefix} module client shutdown successfully.`);
  } catch (error) {
    winston.error(
      `${logPrefix} error during shutdown due to ${JSON.stringify(error)}`
    );
  }
}

/**
 * Send message to azure function for requesting all available updates.
 *
 * @param cb function which get payload of azure function
 */
async function sendGetUpdateInfos(cb: (error, req, res) => void) {
  const logPrefix = `systemInfo::sendGetUpdateInfos`;
  const azureFuncName = `get-mdclight-updates`;
  const commandId = uuid();
  const callbackName = commandId;

  winston.info(`${logPrefix} registering ${commandId}`);
  try {
    moduleClient.onMethod(callbackName, (req, res) => cb(null, req, res));
    winston.info(`${logPrefix} ${commandId} registered.`);
  } catch (err) {
    winston.error(`${logPrefix} ${commandId} already registered.`);
  }

  const payload: CommandEventPayload = {
    locale: 'en'
  };
  const msg = new Message(JSON.stringify(payload));

  msg.properties.add('messageType', 'command');
  msg.properties.add('moduleId', process.env.IOTEDGE_MODULEID);
  msg.properties.add('command', azureFuncName);
  msg.properties.add('commandId', commandId);
  msg.properties.add('methodName', callbackName);

  await moduleClient.sendEvent(msg).catch((error) => {
    const msg = `Error sending event msg'`;
    winston.error(`${logPrefix} ${msg} ${inspect(error)}`);
    cb(new Error(msg), null, null);
  });
}

/**
 *
 * @param cb Callback function to receive the response from azure function backend.
 * @param versions
 */
async function sendMdclUpdateCommand(
  cb: (error, req, res) => void,
  infos: {
    release: VersionInformation['release'];
    baseLayerVersion: VersionInformation['BaseLayerVersion'];
  }
) {
  const logPrefix = `systemInfo::sendMdclUpdateCommand`;
  const azureFuncName = `update-mdclight-version`;
  const commandId = uuid();
  const callbackName = commandId;

  winston.info(`${logPrefix} registering ${commandId}`);
  try {
    moduleClient.onMethod(callbackName, (req, res) => cb(null, req, res));
    winston.info(`${logPrefix} ${commandId} registered.`);
  } catch (err) {
    winston.error(`${logPrefix} ${commandId} already registered.`);
  }

  const payload: CommandEventPayload = {
    release: infos.release,
    baseLayerVersion: infos.baseLayerVersion
  };
  const msg = new Message(JSON.stringify(payload));

  msg.properties.add('messageType', 'command');
  msg.properties.add('moduleId', process.env.IOTEDGE_MODULEID);
  msg.properties.add('command', azureFuncName);
  msg.properties.add('commandId', commandId);
  msg.properties.add('methodName', callbackName);

  await moduleClient.sendEvent(msg).catch((error) => {
    const msg = `Error sending event msg'`;
    winston.error(`${logPrefix} ${msg} ${inspect(error)}`);
    cb(new Error(msg), null, null);
  });
}

/**
 * Performs factory reset
 * @param request HTTP Request
 * @param response
 */
async function systemFactoryResetHandler(request: Request, response: Response) {
  try {
    await configManager.factoryResetConfiguration();
    response.status(200).send();
  } catch (e) {
    response.sendStatus(500);
  }
}

export const systemInfoHandlers = {
  systemInfoGet: systemInfoGetHandler,
  updateGet: getMDCLUpdates,
  updateMDCL: updateMdcl,
  systemFactoryReset: systemFactoryResetHandler
};
